---
tags:
  - learn/program/python
---

# Pandas数据结构

```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
```

为了在引用模块时书写方便，上面的代码用as分别给这几个模块起了别名。后续见到 pd 就代表 Pandas，见到 np 代表NumPy，见到 plt 代表matplotlib.pyplot，均已默认导入程序。

## Series数据结构

### Series是什么

Series是一种类似于一维数组的对象，由一组数据及一组与之相关的数据标签（即索引）组成。

```python
>>>
0 A
1 B
2 C
3 D
4 E
dtype:object
```

上面这样的数据结构就是Series，第一列数字是数据标签，第二列是具体的数据，数据标签与数据是一一对应的。上面的数据用Excel表展示如下：

| 数据标签 | 数据 |
| --- | --- |
| 0 | A |
| 1 | B |
| 2 | C |
| 3 | D |
| 4 | E |

### 创建一个Series

创建一个Series利用的方法是`pd.Series()`，通过传入不同的对象即可实现。

传入一个列表

```python
>>> S1 = pd.Series(['a','b','c','d'])
>>> S1
0    a
1    b
2    c
3    d
dtype: object
```

如果只是传入一个列表不指定数据标签，那么Series会默认使用从0 开始的数做数据标签，上面的0、1、2、3就是默认的数据标签。

指定索引

直接传入一个列表会使用默认索引，也可以通过设置index参数来自定义索引。

```python
>>> S2 = pd.Series([1,2,3,4],index = ['a','b','c','d'])
>>> S2
a    1
b    2
c    3
d    4
dtype: int64
```

传入一个字典

```python
>>> S3 = pd.Series({'a':1,'b':2,'c':3,'d':4})
>>> S3
a    1
b    2
c    3
d    4
dtype: int64
```

将数据与数据标签以key:value（字典）的形式传入，这样字典的key值就是数据标签，value就是数据值。

利用index方法获取Series的索引

```python
>>> S1.index
RangeIndex(start=0, stop=4, step=1)
>>> S2.index
Index(['a', 'b', 'c', 'd'], dtype='object')
```

利用values方法获取Series的值

```python
>>> S1.values
array(['a', 'b', 'c', 'd'], dtype=object)
>>> S2.values
array(['1','2','3','4'], dtype=int64)
```

## DataFrame 表格型数据结构

### DataFrame是什么

Series是由一组数据与一组索引（行索引）组成的数据结构，而 DataFrame是由一组数据与一对索引（行索引和列索引）组成的表格型数据结构。之所以叫表格型数据结构，是因为DataFrame的数据形式和 Excel的数据存储形式很相近。

下面就是一个简单的DataFrame数据结构。

```python
     技能	
第一 Excel
第二 SQL
第三 Python
第四 PPT
```

上面这种数据结构和Excel的数据结构很像，既有行索引又有列索引，由行索引和列索引确定唯一值。如果把上面这种结构用Excel表展示如下：

|  | 技能 |
| --- | --- |
| 第一 | Excel |
| 第二 | SQL |
| 第三 | Python |
| 第四 | PPT |

### 创建一个DataFrame

创建DataFrame使用的方法是`pd.DataFrame()`，通过传入不同的对象即可实现。

传入一个列表

```python
>>> df1 = pd.DataFrame(['a','b','c','d'])
>>> df1
   0
0  a
1  b
2  c
3  d
```

只传入一个单一列表时，该列表的值会显示成一列，且行和列都是从0开始的默认索引。

传入一个嵌套列表

```python
>>> df2 = pd.DataFrame([['a','A'],['b','B'],['c','C'],['d','D']])
>>> df2
   0  1
0  a  A
1  b  B
2  c  C
3  d  D
```

当传入一个嵌套列表时，会根据嵌套列表数显示成多列数据，行、列索引同样是从0开始的默认索引。列表里面嵌套的列表也可以换成元组：`df2 = pd.DataFrame([('a','A'),('b','B'),('c','C'),('d','D')])`

指定行、列索引

如果只给DataFrame()方法传入列表，DataFrame()方法的行、列索引都是默认值，则可以通过设置columns参数自定义列索引，设置index 参数自定义行索引。

```python
>>> df3 = pd.DataFrame([['a','A'],['b','B'],['c','C'],['d','D']],
		index = ['一','二','三','四'],
		columns = ['小写','大写'])
>>> df3
  小写 大写
一  a  A
二  b  B
三  c  C
四  d  D
```

传入一个字典

```python
>>> data = {'小写':['a','b','c','d'],'大写':['A','B','C','D']}
>>> df4 = pd.DataFrame(data)
>>> df4
  小写 大写
0  a  A
1  b  B
2  c  C
3  d  D
```

直接以字典的形式传入DataFrame时，字典的key值就相当于列索引，这个时候如果没有设置行索引，行索引还是使用从0开始的默认索引，同样可以使用index参数自定义行索引，代码如下：

```python
>>> df4 =pd.DataFrame(data,index=['一','二','三','四'])
>>> df4
  小写 大写
一  a  A
二  b  B
三  c  C
四  d  D
```

获取DataFrame的行、列索引

```python
# 利用columns方法获取DataFrame的列索引。
>>> df2.columns
RangeIndex(start=0, stop=2, step=1)
>>> df3.columns
Index(['小写', '大写'], dtype='object')

# 利用index方法获取DataFrame的行索引。
>>> df2.index
RangeIndex(start=0, stop=4, step=1)
>>> df3.index
Index(['一', '二', '三', '四'], dtype='object')
```

### 获取DataFrame的值

获取DataFrame的值就是获取DataFrame中的某些行或列，有关行、列的选择在第6章会有详细讲解。

# 获取数据源

## 导入外部数据

导入数据主要用到的是Pandas里的`read_x()`方法，x表示待导入文件的格式。

### 导入.xlsx文件

在 Python中导入.xlsx文件的方法是read_excel()。

基本导入
在导入文件时首先要指定文件路径，也就是这个文件在电脑中的哪个文件夹下存着。

电脑中的文件路径默认使用`\`，这个时候需要在路径前面加一个`r`（转义符）避免路径里面的\被转义。也可以不加 r，但是需要把路径里面的所有\转换成/，这个规则在导入其他格式文件时也是一样的，我们一般选择在路径前面加r。

```python
df = pd.read_excel(r'D:\xx\xx\xx\xx.xlsx')
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx')
```

指定导入哪个Sheet

.xlsx格式的文件可以有多个Sheet，你可以通过设定sheet_name参数来指定要导入哪个Sheet的文件。还可以传入Sheet的顺序，从0开始计数。如果不指定sheet_name参数时，那么默认导入的都是第一个Sheet的文件。

```python
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 'sheet1')
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0)
```

指定行索引

将本地文件导入DataFrame时，行索引使用的从0开始的默认索引，可以通过设置`index_col`参数来设置。

```python
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, index_col = 0)
```

`index_col`表示用.xlsx文件中的第几列做行索引，从0开始计数。 

指定列索引

将本地文件导入DataFrame时，默认使用源数据表的第一行作为列索引，也可以通过设置header参数来设置列索引。header参数值默认为0，即用第一行作为列索引；也可以是其他行，只需要传入具体的那一行即可；也可以使用默认从0开始的数作为列索引。

```python
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, header = 0)
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, header = 1)
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, header = None)
```

指定导入列

有的时候本地文件的列数太多，而我们又不需要那么多列时，我们就可以通过设定usecols参数来指定要导入的列。

```python
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, usecols = 0)
df = pd.read_excel('D:/xx/xx/xx/xx.xlsx', sheet_name = 0, usecols = [0,2])
```

可以给usecols 参数具体的某个值，表示要导入第几列，同样是从0开始计数，也可以以列表的形式传入多个值，表示要传入哪些列。

### 导入.csv文件

在 Excel 中导入.csv 格式的文件和打开.xlsx 格式的文件一样，双击即可。而在Python中导入.csv文件用的方法是read_csv()。
直接导入只需要指明文件路径即可。

指明分隔符号

在Excel和DataFrame中的数据都是很规整的排列的，这都是工具在后台根据某条规则进行切分的。read_csv()默认文件中的数据都是以逗号分开的，但是有的文件不是用逗号分开的，这个时候就需要人为指定分隔符号，否则就会报错。

[新建一个以空格作为分隔符号的文件](https://zh-cn.extendoffice.com/documents/excel/7228-excel-change-delimiter-when-saving-as-csv.html)，如果用默认的逗号作为分隔符号，导入的数据还是一个整体，并没有被分开，把分隔符号换成空格以后再看：

```python
df = pd.read_csv('D:/xx/xx/xx/xx.csv', sep = ' ')
```

使用正确的分隔符号以后，数据被规整地分好了。常见的分隔符号除了逗号、空格，还有制表符(\t)。

指明读取行数

假设现在有一个几百兆的文件，你想了解一下这个文件里有哪些数据，那么这个时候你就没必要把全部数据都导入，你只要看到前面几行即可，因此只要设置 nrows参数即可。

```python
df = pd.read_csv('D:/xx/xx/xx/xx.csv', sep = ' ', nrows = 2)
```

指定编码格式

Python用得比较多的两种编码格式是UTF-8和GBK，默认编码格式是 UTF-8。我们要根据导入文件本身的编码格式进行设置，通过设置参数encoding来设置导入的编码格式。有的时候两个文件看起来一样，它们的文件名一样，格式也一样，但如果它们的编码格式不一样，也是不一
样的文件，比如当你把一个Excel文件另存为时会出现两个选项，虽然都是.csv文件，但是这两种格式代表两种不同的文件。

如果是CSV UTF-8(逗号分隔)(*.csv)格式的文件，那么导入时就需要加*encoding*参数*。*
你也可以不加*encoding*参数，因为Python默认的编码格式就是UTF-8。
**如果是CSV(逗号分隔)(*.csv)格式的文件，那么在导入的时候就需要把编码格式更改为gbk，如果使用UTF-8就会报错。

```python
df = pd.read_csv('D:/xx/xx/xx/xx.csv', encoding = 'utf-8')
df = pd.read_csv('D:/xx/xx/xx/xx.csv')
df = pd.read_csv('D:/xx/xx/xx/xx.csv', encoding = 'gbk')
```

engine指定

当文件路径或者文件名中包含中文时，如果还用上面的导入方式就会报错。这个时候我们就可以通过设置engine参数来消除这个错误。这个错误产生的原因是当调用read_csv()方法时，默认使用C语言作为解析语 言，我们只需要把默认值C更改为Python就可以了，如果文件格式是CSV UTF-8(逗号分隔)(*.csv)，那么编码格式也需要跟着变为utf-8-sig，如果文件格式是CSV(逗号分隔)(*.csv)格式，对应的编码格式则为gbk。

```python
df = pd.read_csv('D:/xx/xx/xx/xx.csv', engine = 'python', encoding = 'utf-8-sig')
```

.csv 文件也涉及行、列索引设置及指定导入某列或某几列，设定方法与导入.xlsx文件一致。

### 导入.txt文件

Excel实现
在Excel中导入.txt文件时，我们需要通过依次单击菜单栏中的数据→获取外部数据→自文本，然后选择要导入的.txt文件所在的路径。选完路径以后会出现分隔符界面，预览文件就是我们要导入的文件，确任无误后按下一步按钮即可。因为我们举例的.txt 文件是用空格分开的，所以在分隔符号项勾选空格复选框，如果待导入的.txt 文件是用其他分隔符号分隔的，那么选择对应的分隔符号，然后直接按完成按钮即可。

Python实现

`read_table()`是将利用分隔符分开的文件导入DataFrame的通用函数。它不仅可以导入.txt文件，还可以导入.csv文件。

```python
df = pd.read_table('D:/xx/xx/xx/xx.txt', sep = ' ')
```

从上面的代码可以看出，函数在导入.csv文件时，与read_csv()函数不同的是，即使是逗号分隔的文件也需要用sep指明分隔符号，而不像 read_csv()函数那样，如果文件是逗号分隔，则可以不写。

read_table()函数其他参数的用法与read_csv()函数的基本一致。

### 导入sql文件

Excel实现

Excel 可以直接连接数据库，通过依次单击菜单栏中的数据>自其他来源导入 sql文件。如果你的数据库是SQL Server，那么直接选择来自 SQL Server即可；如果是MySQL 数据库，那么你需要选择来自数据连接向导，然后通过建立数据向导来与MySQL连接。

Python实现

Python导入sql文件主要分为两步，第一步将Python与数据库进行连接，第二步是利用Python执行sql查询语句。

将Python与数据库连接时利用的是pymysql模块，这个模块Anaconda没有，需要我们手动安装，打开Anaconda Promt，然后输入pip install pymysql进行安装即可，安装完成以后直接用import导入就可以使用。

```python
import pymysql
eng = pymysql.connect(host='localhost',user='user',password='password',db='db',charset='utf8')
'''
user：用户名
password：密码
host：数据库地址/本机使用loaclhost
db：数据名
charset：数据库编码，一般为UTF-8
'''
```

连接好数据库以后，我们就可以执行sql查询语句，利用的是`read_sql(sql,con)`方法。参数sql是要执行的sql语句，con是第一步创建好的数据库连接，即eng。

```python
>>> sql = 'SELECT*FROM memberinfo'
>>> eng = pymysql.connect('118.190.201.130','zhangjh','zhangjh2018','test',charset = 'utf8')
>>> df = pd.read_sql(sql,eng)
>>> df
```

除了 sql 和 con 这两个关键参数，read_table()函数也有用来设置行索引的参数index_col，设置列索引的columns。

## 新建并熟悉数据

这里的新建数据主要指新建 DataFrame 数据，此前在第三章讲过，利用pd.DataFrame()方法进行新建。

当我们有了数据源以后，先别急着分析，应该先熟悉数据，只有对数据充分熟悉了，才能更好地进行分析。

### 利用head预览前几行

当数据表中包含数据行数过多时，而我们又想看一下每一列数据都是什么样的数据时，就可以只把数据表中前几行数据显示出来进行查看。

Excel实现
Excel 其实没有严格意义的显示前几行，当你打开一个数据表时，所有数据就全展示出来了，如果数据的行数过多，则可以通过滚动条来控制。

Python实现
在Python中，当一个文件导入后，可以用head()方法来控制要显示哪些行。只需要在head后面的括号中输入要展示的行数即可，默认展示前5行。

```python
df.head() # 默认展示前5行
df.head(2) # 只展示前2行
```

### 利用shape获取数据表的大小

熟悉数据的第一点就是先看一下数据表的大小，即数据表有多少行、多少列。

Excel实现
在Excel中查看数据表有多少行，一般都是选中某一列，右下角就会出现该表的行数，如下图所示。在Excel中选中某一行，右下角就会出现该表的列数。

Python实现

在Python中获取数据表的行、列数利用的是shape方法。

```python
df.shape
```

shape方法会以元组的形式返回行、列数，代码中的(4,4)表示df 表有4行4列数据。这里需要注意的是，Python中利用shape方法获取行数和列数时不会把行索引和列索引计算在内，而Excel中是把行索引和列索引计算在内的。

### 利用info获取数据类型

熟悉数据的第二点就是看一下数据类型，不同的数据类型的分析思路是不一样的，比如数值类型的数据可以求均值，但是字符串类型的数据就没法求均值了。

Excel实现
在Excel中，若想看某一列数据具体是什么类型的，只要把这一列选中，然后在菜单栏中的数字那一栏就可以看到这一列的数据类型。

Python实现

在Python中我们可以利用info()方法查看数据表中的数据类型，而且不需要一列一列查看，在调用info()方法以后就会输出整个表中所有列的数据类型。

```python
>>>df.info()
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 4 entries, 0 to 3
Data columns (total 4 columns):
 #   Column  Non-Null Count  Dtype         
---  ------  --------------  -----         
 0   编号      4 non-null      object        
 1   年龄      4 non-null      int64         
 2   性别      4 non-null      object        
 3   注册时间    4 non-null      datetime64[ns]
dtypes: datetime64[ns](1), int64(1), object(2)
memory usage: 260.0+ bytes
None
```

通过info()方法可以看出表df的行索引index是0~3，总共4columns，分别是编号、年龄、性别及注册时间，且4columns中只有年龄是int类型，其他columns都是object类型，共占用内存208bytes。

### 利用describe获取数值分布情况

熟悉数据的第三点就是掌握数值的分布情况，即均值是多少，最值是多少，方差及分位数分别又是多少。

Excel实现
在Excel中如果想看某列的数值分布情况，那么手动选中这一列，在Excel的右下角就会显示出这一列的平均值、计数及求和，且只显示这三个指标。如果想了解其他指标（求最值、方差、标准差）的具体计算方法，可参考8.3节。

Python实现
在Python中只需要利用describe()方法就可以获取所有数值类型字段的分布值。

```python
>>>df.describe()
						年龄
count   4.000000
mean   25.500000
std     7.505553
min    17.000000
25%    20.750000
50%    25.500000
75%    30.250000
max    34.000000
```

表df中只有年龄这一列是数值类型，所以调用describe()方法时，只计算了年龄这一列的相关数值分布情况。

我们可以新建一个含有多列数值类型字段的DataFrame。

```python
>>> df = pd.DataFrame([[20,500,2],[25,800,3],[30,900,3],[28,700,2]],columns=['年龄','收入','家属数'])
>>> df.describe()
				年龄          收入      家属数
count   4.000000    4.000000  4.00000
mean   25.750000  725.000000  2.50000
std     4.349329  170.782513  0.57735
min    20.000000  500.000000  2.00000
25%    23.750000  650.000000  2.00000
50%    26.500000  750.000000  2.50000
75%    28.500000  825.000000  3.00000
max    30.000000  900.000000  3.00000
```

上面的表df中年龄、收入、家属数都是数值类型，所以在调用 describe()方法的时候，会同时计算这三列的数值分布情况。

# 数据预处理

## 缺失值处理

缺失值就是由某些原因导致部分数据为空，对于为空的这部分数据我们一般有两种处理方式，一种是删除，即把含有缺失值的数据删除；另一种是填充，即把缺失的那部分数据用某个值代替。

5.1.1 缺失值查看

对缺失值进行处理，首先要把缺失值找出来，也就是查看哪列有缺失值。

Excel实现

在Excel中我们先选中一列没有缺失值的数据，看一下这一列数据共有多少个，然后把其他列的计数与这一列进行对比，小于这一列数据个数的就代表有缺失值，差值就是缺失个数。

如果想看整个数据表中每列数据的缺失情况，则要挨个选中每一列去判断该列是否有缺失值。如果数据不是特别多，你想看到具体是哪个单元格缺失，可以利用定位条件（按快捷键Ctrl+G可弹出该对话框）查找。在定位条件对话框中选择空值，单击确定就会把所有的空值选中。

Python实现

在 Python 中直接调用 `info()`方法就会返回每一列的缺失情况。
Python中缺失值一般用NaN表示，从用info()方法的结果来看，性别这一列是3 non-null object，表示性别这一列有3个非null值，而其他列有4个非null值，说明性别这一列有1个null值。 我们还可以用`isnull()`方法来判断哪个值是缺失值，如果是缺失值则返回True，如果不是缺失值则返回False。

5.1.2 缺失值删除

缺失值分为两种，一种是一行中某个字段是缺失值；另一种是一行中的字段全部为缺失值，即为一个空白行。

Excel实现
在Excel中，这两种缺失值都可以通过在定位条件（按快捷键Ctrl+G 可弹出该对话框）对话框中选择空值找到。这样含有缺失值的部分就会被选中，包括某个具体的单元格及一整行，然后单击鼠标右键在弹出的删除对话框中选择删除整行选项，并单击确定按钮即可实现整行的删除。

Python实现

在 Python 中，我们利用的是`dropna()`方法，dropna()方法默认删除含有缺失值的行，也就是只要某一行有缺失值就把这一行删除。

运行dropna()方法以后，删除含有NaN值的行，返回删除后的数据。
如果想删除空白行，只要给dropna()方法传入一个参数how = all即可，这样就会只删除那些全为空值的行，不全为空值的行就不会被删除。
上表第二行中只有性别这个字段是空值，所以在利用dropna(how = "all")的时候并没有删除第二行，只是把全为NaN值的第三行删掉了。

5.1.3 缺失值填充

一般情况下只要数据缺失比例不是过高（不大于30%），尽量别删除，而是选择填充。

Excel实现
在Excel中，缺失值的填充和缺失值删除一样，利用的也是定位条件，先把缺失值找到，然后在第一个缺失值的单元格中输入要填充的值，最常用的就是用0填充，输入以后按Ctrl+Enter组合键就可以对所有缺失值进行填充。
年龄用数字填充合适，但是性别用数字填充就不太合适，那么可不可以分开填充呢？答案是可以的，选中要填充的那一列，按照填充全部数据的方式进行填充即可，只不过要填充几列，需要执行几次操作。

上图是填充前后的对比，年龄这一列我们用平均值填充，性别这一列我们用众数填充。
除了用0填充、平均值填充、众数（大多数）填充，还有向前填充（即用缺失值的前一个非缺失值填充，比如上例中编号A3对应的缺失年龄的前一个非缺失值就是16）、向后填充（与向前填充对应）等方式。

Python实现
在Python中，我们利用的`fillna()`方法对数据表中的所有缺失值进行填充，在fillna后面的括号中输入要填充的值即可。
在 Python 中我们也可以按不同列填充，只要在 fillna()方法的括号中指明列名即可。
上面代码中只针对性别这一列进行了填充，其他列未进行任何更改。
也可以同时对多列填充不同的值：

```python
>>>df.fillna({'性别':'男','年龄':'30'})
```

## 重复值处理

重复数据就是同样的记录有多条，对于这样的数据我们一般做删除处理。

假设你是一名数据分析师，你的主要工作是分析公司的销售情况，现有公司2018年8月的销售明细（已知一条明细对应一笔成交记录），你想看一下8月整体成交量是多少，最简单的方式就是看一下有多少条成交明细。但是这里可能会有重复的成交记录存在，所以要先删除重复项。

Excel实现
在Excel中依次单击菜单栏中的数据>数据工具>删除重复值，就可以删除重复数据了。

Excel 的删除重复值默认针对所有值进行重复值判断，比如有订单编号、客户姓名、唯一识别码（类似于身份证号）、成交时间这四个字段，Excel会判断这四个字段是否都相等，只有都相等时才会删除，且保留第一个（行）值。你知道了公司8月成交明细以后，你想看一下8月总共有多少成交客户，且每个客户在8月首次成交的日期。
查看客户数量只需要按客户的唯一识别码进行去重就可以了。
Excel默认是全选，我们可以取消全选，选择唯一识别码进行去重，这样只要唯一识别码重复就会被删除，如下图所示。
因为Excel默认会保留第一条记录，而我们又想要获取每个客户的较早成交日期，所以我们需要先对时间进行升序排列，让较早的日期排在前面，这样在删除的时候就会保留较早的成交日期。
删除前后的对比如下图所示。

Python实现

在Python中我们利用`drop_duplicates()`方法，该方法默认对所有值进行重复值判断，且默认保留第一个（行）值。

我们也可以只针对某一列或某几列进行重复值删除的判断，只需要在drop_duplicates()方法中指明要判断的列名即可。
也可以利用多列去重，只需要把多个列名以列表的形式传给参数subset即可。比如按姓名和唯一识别码去重。

```python
df.drop_duplicates(subset = ['姓名','唯一识别码'], keep= 'last')
df.drop_duplicates(subset = ['姓名','唯一识别码'], keep= False)
```

还可以自定义删除重复项时保留哪个，默认保留第一个，也可以设置保留最后一个，或者全部不保留。通过传入参数keep进行设置，参数 keep默认值是first，即保留第一个值；也可以是last，保留最后一个值；还可以是False，即把重复值全部删除。

## 异常值的检测与处理

异常值就是相比正常数据而言过高或过低的数据，比如一个人的年龄是0岁或者300岁都算是一个异常值，因为这和实际情况差距过大。

5.3.1 异常值检测

要处理异常值首先要检测，也就是发现异常值，发现异常值的方式主要有以下三种：

●根据业务经验划定不同指标的正常范围，超过该范围的值算作异常值。
●通过绘制箱形图，把大于（小于）箱形图上边缘（下边缘）的点称为异常值。
●如果数据服从正态分布，则可以利用3σ 原则；如果一个数值与平均值之间的偏差超过3倍标准差，那么我们就认为这个值是异常值。

箱形图如下图所示，关于箱形图的绘制方法我们会在第13章介绍。下图为正态分布图，我们把大于μ+3σ的值称为异常值。

5.3.2 异常值处理
对于异常值一般有以下几种处理方式。
● 最常用的处理方式就是删除。
● 把异常值当作缺失值来填充。
● 把异常值当作特殊情况，研究异常值出现的原因。

Python实现
在Python中，删除异常值用到的方法和Excel中的方法原理类似， Python中是通过过滤的方法对异常值进行删除。比如 df 表中有年龄这个指标，要把年龄大于200的值删掉，你可以通过筛选把年龄不大于200的筛出来，筛出来的部分就是删除大于200的值以后的新表。

对异常值进行填充，就是对异常值进行替换，利用replace()方法可以对特定的值进行替换。

关于数据筛选和数据替换会在接下来的章节介绍。

## 数据类型转换

5.4.1 数据类型

Excel实现
在Excel中常用的数据类型就是在菜单栏中数字选项下面的几种，你也可以选择其他数据格式。
在Excel中只要选中某一列就可以在菜单栏看到这一列的数据类型。
当选中成交时间这一列时，菜单栏中就会显示日期，表示成交时间这一列的数据类型是日期格式。

Python实现
在 Python 中，不仅可以用info()方法获取每一列的数据类型，还可以通过 dtype方法来获取某一列的数据类型。

5.4.2 类型转换
我们在前面说过，不同数据类型的数据可以做的事情是不一样的，所以我们需要对数据进行类型转化，把数据转换为我们需要的类型。

Excel实现
在Excel中如果想更改某一列的数据类型，只要选中这一列，然后在数字菜单栏中通过下拉菜单选择你要转换的目标类型即可实现。

Python实现

在Python中，我们利用astype()方法对数据类型进行转换，astype后面的括号里指明要转换的目标类型即可。

## 索引设置

索引是查找数据的依据，设置索引的目的是便于我们查找数据。举个例子，你逛超市买了很多食材，回到家以后要把它们放在冰箱里，放的过程其实就是一个建立索引的过程，比如蔬菜放在冷藏室，肉类放在冷冻室，这样在找的时候就能很快找到。

5.5.1 为无索引表添加索引

有的表没有索引，这时要给这类表加一个索引。

Excel实现
在Excel中，一般都是有索引的，如果没索引数据看起来会很乱， 当然也会有例外，数据表就是没有索引的。这个时候插入一行一列就是为表添加索引。
添加索引前后的对比如下图所示，序号列为行索引，字段名称为列索引。

Python实现

在Python中，如果表没有索引，会默认用从0开始的自然数做索引。

通过给表df的columns参数传入列索引值，index参数传入行索引值 达到为无索引表添加索引的目的。

```python
df.columns = ['订单编号','客户姓名','唯一识别码','成交时间']
df.index = [1,2,3,4,5,6]
```

5.5.2 重新设置索引

重新设置索引，一般指行索引的设置。有的表虽然有索引，但不是我们想要的索引，比如现在有一个表是把序号作为行索引，而我们想要把订单编号作为行索引，该怎么实现呢？

Excel实现
在Excel中重新设置行索引比较简单，你想让哪一列做行索引，直接把这一列拖到第一列的位置即可。

Python实现

在Python中可以利用set_index()方法重新设置索引列，在set_index()里指明要用作行索引的列的名称即可。

```python
df.set_index('订单编号')
```

在重新设置索引时，还可以给 set_index()方法传入两个或多个列名，我们把这种一个表中用多列来做索引的方式称为层次化索引，层次化索引一般用在某一列中含有多个重复值的情况下。层次化索引的例子，如下所示，其中 a、b、c、d 分别有多个重复值。

5.5.3 重命名索引

重命名索引是针对现有索引名进行修改的，就是改字段名。

Excel实现
在Excel中重命名索引比较简单，就是直接修改字段名。

Python实现

在Python中重命名索引，我们利用的是rename()方法，在rename后的括号里指明要修改的行索引及列索引名。

```python
# 同时重命名行列索引
df.rename(columns = {'订单编号':'新订单编号','客户姓名':'新客户姓名'} index = {1:'一',2:'二',3:'三'})
```

5.5.4 重置索引

重置索引主要用在层次化索引表中，重置索引是将索引列当作一个columns进行返回。

在下图左侧的表中，Z1、Z2是一个层次化索引，经过重置索引以后，Z1、Z2这两个索引以columns的形式返回，变为常规的两列。
在Excel中，我们要进行这种转换，直接通过复制、粘贴、删除等功能就可以实现，比较简单。

我们主要讲一下在Python中怎么实现。
在Python利用的是reset_index()方法，reset_index()方法常用的参数如下：

`reset_index(level=None,drop=False,inplace=False)`

level参数用来指定要将层次化索引的第几级别转化为columns，第一个索引为0级，第二个索引为1级，默认为全部索引，即默认把索引全部转化为columns。
drop参数用来指定是否将原索引删掉，即不作为一个新的 columns，默认为False，即不删除原索引。 inplace参数用来指定是否修改原数据表。

```python
df.reset_index() # 默认将全部 index 转化为 columns
df.reset_index(level = 0) # 将第 0 级索引转化为 columns
df.reset_index(drop = True) # 将原索引删除,不加入 columns
```

reset_index()方法常用于数据分组、数据透视表中。

# 数据选择

常规的数据选择主要有列选择、行选择、行列同时选择三种方式。

## 列选择

6.1.1 选择某一列/某几列

Excel实现
在Excel中选择某一列直接用鼠标选中这一列即可；如果要同时选 择多列，且待选择的列不是相邻的，这个时候就可以先选中其中一列，
然后按住Ctrl键不放，再选择其他列。举个例子，同时选择客户姓名和成交时间这两列。

Python实现

在Python中我们要想获取某列只需要在表df后面的方括号中指明要选择的列名即可。如果是一列，则只需要传入一个列名；如果是同时选择多列，则传入多个列名即可，多个列名用一个list存起来。

在Python中我们把这种通过传入列名选择数据的方式称为普通索引。除了传入具体的列名，我们还可以传入具体列的位置，即第几列，对数据进行选取，通过传入位置来获取数据时需要用到iloc方法。

```python
>>> df.iloc[:,[0,2]] # 获取第1列和第3列的数值
	编号 性别
0  A1  男
1  A2  女
2  A3  男
3  A4  女
```

在上面的代码中，iloc 后的方括号中逗号之前的部分表示要获取的行的位置，只输入一个冒号，不输入任何数值表示获取所有的行；逗号之后的方括号表示要获取的列的位置，列的位置同样是也是从0开始计数。

我们把这种通过传入具体位置来选择数据的方式称为位置索引。

6.1.2 选择连续的某几列

Excel实现
在Excel中，要选择连续的几列时，直接用鼠标选中这几列即可操 作。当然了，你也可以先选择一列，然后按住 Ctrl 键再去选择其他列， 由于要选取的列是连续的，因此没必要这么麻烦。

Python实现
在Python中可以通过前面介绍的普通索引和位置索引获取某一列或多列的数据。当你要获取的是连续的某几列，用普通索引和位置索引也是可以做到的，但是因为你要获取的列是连续的，所以只要传入这些连续列的位置区间即可，同样需要用到 iloc方法。

```python
df.iloc[:,0:3] # 获取第1列到第4列的值
```

在上面的代码中，iloc 后的方括号中逗号之前的表示选择的行，当只传入一个冒号时，表示选择所有行；逗号后面表示要选择列的位置区间，0:3表示选择第1列到第4列之间的值（包含第1列但不包含第4列），我们把这种通过传入一个位置区间来获取数据的方式称为切片索引。

## 行选择

6.2.1 选择某一行/某几行

Excel实现
在Excel中选择行与选择列的方式是一样的，先选择一行，按住Ctrl 键再选择其他行。

Python实现

在Python中，获取行的方式主要有两种，一种是普通索引，即传入具体行索引的名称，需要用到loc方法；另一种是位置索引，即传入具体的行数，需要用到iloc方法。 为了让大家看得更清楚，我们对行索引进行自定义。

```python
df.loc['一'] # 选择一行
df.loc['一','二'] # 选择第一行和第二行
df.loc[0] # 选择第一行
df.loc[[0,1]] # 选择第一行和第二行
```

6.2.2 选择连续的某几行

Excel实现
在Excel中选择连续的某几行与选择连续的某几列方法一致，不再赘述。

Python实现
在Python中，选择连续的某几行时，你同样可以把要选择的每一个行索引名字或者行索引的位置输进去。很显然这是没有必要的，只要把连续行的位置用一个区间表示，然后传给iloc即可。

6.2.3 选择满足条件的行

前两节获取某一列时，获取的是这一列的所有行，我们还可以只筛选出这一列中满足条件的值。
比如年龄这一列，需要把非异常值（大于200的属于异常值），即小于200岁的年龄筛选出来，该怎么实现呢？

Excel实现
在Excel中我们直接使用筛选功能，将满足条件的值筛选出来，筛 选方法如下图所示。
筛选年龄小于200的数据前后的对比如下图所示。

Python实现
在Python中，我们直接在表名后面指明哪列要满足什么条件，就可 以把满足条件的数据筛选出来。

```python
df[df['年龄']<200] # 选择年龄小于200的数据
df[(df['']<200)&(df['唯一识别码']<102)]
```

我们把上面这种通过传入一个判断条件来选择数据的方式称为布尔索引。

传入的条件还可以是多个，如选择年龄小于200且唯一识别码小于102的数据。

## 行列同时选择

上面的数据选择都是针对单一的行或列进行选择，实际业务中我们也会用到行、列同时选择，所谓的行、列同时选择就是选择出行和列的相交部分。
例如，我们要选择第二、三行和第二、三列相交部分的数据。
行列同时选择在Excel中主要是通过鼠标拖曳实现的，与前面的单一行/列选择方法一致，此处不再赘述，接下来主要讲讲在Python中如何实现。

6.3.1 普通索引+普通索引选择指定的行和列

普通索引+普通索引就是通过同时传入行和列的索引名称进行数据选择，需要用到loc方法。

loc方法中的第一对方括号表示行索引的选择，传入行索引名称； loc方法中的第二对方括号表示列索引的选择，传入列索引名称。

```python
df.loc[['一','三'],['订单编号','唯一识别码']]
```

6.3.2 位置索引+位置索引选择指定的行和列

位置索引+位置索引是通过同时传入行、列索引的位置来获取数据，需要用到iloc方法。

在iloc方法中的第一对方括号表示行索引的选择，传入要选择行索引的位置；第二对方括号表示列索引的选择，传入要选择列索引的位置。行和列索引的位置都是从0开始计数。

```python
df.iloc[[0,1],[0,2]] # 用iloc方法传入行列位置
```

6.3.3 布尔索引+普通索引选择指定的行和列

布尔索引+普通索引是先对表进行布尔索引选择行，然后通过普通索引选择列。

```python
df[df['年龄']<200,[['订单编号','年龄']]
```

上面的代码表示选择年龄小于200的订单编号和年龄，先通过布尔索引选择出年龄小于200的所有行，然后通过普通索引选择订单编号和年龄这两列。

6.3.4 切片索引+切片索引选择指定的行和列
切片索引+切片索引是通过同时传入行、列索引的位置区间进行数据选择。

```python
df.iloc[0:2,1:2] # 选择第一到第三行，第二到第三列
```

6.3.5 切片索引+普通索引选择指定的行和列
前面我们说过，如果是普通索引，就直接传入行或列名，用loc方法即可；如果是切片索引，也就是传入行或列的位置区间，要用 iloc 方法。如果是切片索引+普通索引，也就是行（列）用切片索引，列（行）用普通索引，这种交叉索引要用ix方法。

```python
df.ix[0:2,['客户姓名','唯一识别码']] # #选择第一到第三行，客户姓名和唯一识别码这两列
```

# 数值操作

## 数值替换

数值替换就是将数值A替换成B，可以用在异常值替换处理、缺失值填充处理中。主要有一对一替换、多对一替换、多对多替换三种替换方法。

7.1.1 一对一替换

一对一替换是将某一块区域中的一个值全部替换成另一个值。已知现在有一个年龄值是240，很明显这是一个异常值，我们要把它替换成一个正常范围内的年龄值（用正常年龄的均值33），怎么实现呢？

Excel实现
在Excel中对某个值进行替换，首先要把待替换的区域选中，如果只是替换某一列中的值，只需要选中这一列即可；如果要在一片区域中进行替换，那么拖动鼠标选中这一片区域。然后依次单击编辑菜单栏中的查找和选择>替换选项（如下图所示）即可调出替换界面。使用快捷键Ctrl+H也可以调出替换界面，分别输入查找内容和替换内容，然后根据需要单击全部替换或者替换即可。

Python实现

在Python中对某个值进行替换利用的是replace()方法，replace(A,B)表示将A替换成B。

```python
df['年龄'].replace(240,33)
df.replace(np.NaN,0)
```

上面的代码是对年龄这一列进行替换，所以把年龄这一列选中，然后调用replace()方法。有时候要对整个表进行替换，比如对全表中的缺失值进行替换，这个时候replace()方法就相当于fillna()方法了。
np.NaN是Python中对缺失值的一种表示方法。

7.1.2 多对一替换

多对一替换就是把一块区域中的多个值替换成某一个值，已知现在有三个异常年龄（240、260、280），需要把这三个年龄都替换成正常范围年龄的平均值33，该怎么实现呢？

Excel实现
在Excel中需要借助if函数来实现多对一替换。已知年龄这一列是D 列，要想对多个异常值进行替换，可以通过如下函数实现：`if(or(D:D=240,D:D=260,D:D=280),33,DD)`

上面的公式借助了Excel中的OR()函数，表示如果D列等于240、260或者280时，该单元格的值为33，否则为D列的值。

Python实现

在 Python 中实现多对一的替换比较简单，同样也是利用 replace()方法，replace([A,B],C)表示将A、B替换成C。

```python
df.replace([240,260,280],33)
```

7.1.3 多对多替换
多对多替换其实就是某个区域中多个一对一的替换。比如将年龄异常值240替换成平均值减一，260替换成平均值，280替换成平均值加一，该怎么实现呢？

Excel实现
若想在Excel中实现，需要借助函数，且需要多个if嵌套语句来实 现，同样已知年龄列为D列，具体函数如下：`=if(D:D=240,32,if(D:D=260,33,if(D:D=280,34,D:D)))`
下图为该函数执行的流程。

替换后的结果如下图所示。

Python实现
在Python中若想实现多对多的替换，同样是借助replace()方法，将替换值与待替换值用字典的形式表示，replace({"A":"a","B":"b"})表示用a替换A，用b替换B。

```python
>>> df.replace({"A":"a","B":"b"})
```

7.2 数值排序

数值排序是按照具体数值的大小进行排序，有升序和降序两种，升序就是数值由小到大排列，降序是数值由大到小排列。

7.2.1 按照一列数值进行排序
按照一列数值进行排序就是整个数据表都以某一列为准，进行升序或降序排列。

Excel实现
在Excel中想要按照某列进行数值排序，只要选中这一列的字段名，然后单击编辑菜单栏下的排序和筛选按钮，在下拉菜单中选择升序或降序选项即可。

Python实现

在 Python 中我们若想按照某列进行排序，需要用到sort_values()方法，在sort_values后的括号中指明要排序的列名，以及升序还是降序排列。

```python
df.sort_values(by = ['col1'], ascending = False)
df.sort_values(by = ['col1'])
```

上面代码表示df表按照col1列进行排序，ascending = False表示按照col1列进行降序排列。ascending 参数默认值为 True，表示升序排列。所以，如果是要根据 col1列进行升序排序，则可以只指明列名，不需要额外声明排序方式。

7.2.2 按照有缺失值的列进行排序

Python实现
在Python中，当待排序的列中有缺失值时，可以通过设置 na_position参数对缺失值的显示位置进行设置，默认参数值为last，可以不写，表示将缺失值显示在最后。

```python
# 通过设置na_position参数将缺失值显示在最前面。
df.sort_value(by = ['销售ID'],na_position = 'first')
```

7.2.3 按照多列数值进行排序

按照多列数值排序是指同时依据多列数据进行升序、降序排列，当第一列出现重复值时按照第二列进行排序，当第二列出现重复值时按照第三列进行排序，以此类推。

Excel实现
在Excel中实现按照多列排序，选中待排序的所有数据，单击编辑菜单栏下的排序和筛选按钮，在下拉菜单中选择自定义排序选项。添加条件就是添加按照排序的列，在次序里面可以单独定义每一列的升序或降序。
举个例子，对下图左侧的Before表先按照销售ID升序排列，当遇到 重复的销售ID时，再按成交时间降序排列，得出下图右侧的After表。

Python实现
用到的方法同样是sort_values()，只要在sort-values后的括号中以列表的形式指明要排序的多列列名及每列的排序方式即可。

```python
df.sort_values(by = ['col1','col2'],ascending = [True,False])
```

上面代码表示df表先按照col1列进行升序排列，当col1列遇到重复时，再按照col2列进行降序排列。对于表df我们依旧先按照销售ID升序排列，当遇到重复的销售ID时，再按成交时间降序排列，代码如下所示。

7.3 数值排名

数值排名和数值排序是相对应的，排名会新增一列，这一列用来存放数据的排名情况，排名是从1开始的。

Excel实现

在Excel中用于排名的函数有RANK.AVG()和RANK.EQ()两个。

当待排名的数值没有重复值时，这两个函数的效果是完全一样的，两个函数的不同在于处理重复值方式的不同。
RANK.AVG(number,ref,order)
number表示待排名的数值，ref表示一整列数值的范围，order用来指明降序还是升序排名。当待排名的数值有重复值时，返回重复值的平均排名。
对销售ID进行平均排名以后的结果如下图所示。图中销售ID为1的值有两个，假设一个排名是1，另一个排名是2，那么二者的均值就是1.5，所以平均排名就是1.5；销售ID为2的值同样有两个，同样假设一个排名为3，另一个排名是4，那么二者的均值是3.5，所以平均排名就是3.5；销售ID为3的值没有重复值，所以排名就是5。

RANK.EQ(number,ref,order)

RANK.EQ 的参数值与 RANK.AVG 的意思一样。当待排名的数值有重复值时， RANK.EQ返回重复值的最佳排名。
对销售ID进行最佳排名以后的结果如下图所示。图中销售ID为1的值有两个，第一个重复值的排名为1，所以两个值的最佳排名均为1；销售ID为2的值也有两个，第一个重复值的排名为3，所以两个值的最佳排名均为3；销售ID为3的值没有重复值，最佳排名为5。

Python实现

在Python中对数值进行排名，需要用到rank()方法。rank()方法主要 有两个参数，一个是ascending，用来指明升序排列还是降序排列，默认 为升序排列，和Excel中order的意思一致；另一个是method，用来指明 待排列值有重复值时的处理情况。下表是参数method可取的不同参数值及说明。

| method | 说明 |
| --- | --- |
| average | 与Excel中的RANK.AVG函数功能一样 |
| first | 按值在所有待排列数据中出现的先后顺序排名 |
| min | 与Excel中RANK.EQ函数功能一样 |
| max | 与min相反，取重复值对应的最大排名 |

```python
>>>df['销售ID']
0    1
1    2
2    1
3    2
4    3
Name:销售ID,dtype:int64

>>> df['销售ID'].rank(method = 'average')
>>> df['销售ID'].rank(method = 'first')
>>> df['销售ID'].rank(method = 'min')
>>> df['销售ID'].rank(method = 'max')
```

method取值为first时的排名情况，销售ID为1的值有两个，第一个出 现的排名为1，第二个出现的排名为2；销售ID为2的以此类推。
method取值为min时的排名情况，与Excel中RANK.EQ函数的一致。
method取值为max时的排名情况，与method取值min时相反，销售 ID为1的值有两个，第二个重复值的排名为2，所以两个值的排名均为2；销售ID为2的值有两个，第二个重复值的排名为4，所以两个值的排名均为4。

7.4 数值删除
数值删除是对数据表中一些无用的数据进行删除操作。

7.4.1 删除列

Excel实现
在Excel中，要删除某一列或某几列，只需要选中这些列，然后单击鼠标右键，在弹出的菜单中选择删除选项即可（或者单击鼠标右键以后按D键）。

Python实现

在Python中，要删除某列，用到的是drop()方法，即在drop方法后的括号中指明要删除的列名或者列的位置，即第几列。

在drop方法后的括号中直接传入待删除列的列名，需要加一个参数 axis，并让其参数值等于1，表示删除列。

```python
df.drop(['销售ID','成交时间'],axis = 1)
# 还可以在drop方法后的括号中直接传入待删除列的位置，但也需要用axis参数。
df.drop(df.columnsp[[4,5]],axis = 1)
# 也可以将列名以列表的形式传给columns参数，这个时候就不需要axis参数了。
df.drop(columns = ['销售ID','成交时间'])
```

7.4.2 删除行

Excel实现
在 Excel 中，要删除某些行使用的方法与删除列是一致的，先选中要删除的行，然后单击鼠标右键，在弹出的下拉菜单中选择删除选项就可以删除行了。

Python实现

在Python中，要删除某些行用到的方法依然是drop()，与删除列类 似的是，删除行也要指明行相关的信息。
在drop方法后的括号中直接传入待删除行的行名，并让axis参数值等于0，表示删除行。

```python
df.drop(['0a','1b'],axis = 0)
```

除了传入行索引名称，还可以在drop方法后的括号中直接传入待删除行的行号，也需要用axis参数，并让其参数值等于0。

```python
df.drop(df.index[[0,1]],axis = 0)
```

也可以将待删除行的行名传给index参数，这个时候就不需要axis参数了。

```python
df.drop(index = ['0a','1b'])
```

7.4.3 删除特定行
删除特定行一般指删除满足某个条件的行，我们前面的异常值删除算是删除特定的行。

Excel实现
在Excel中删除特定行分为两步，第一步先将符合条件的行筛选出来，第二步选中这些筛选出来的行然后单击鼠标右键，在弹出的下拉菜单中选择删除选项。

Python实现

在Python中删除特定行使用的方法有些特殊，我们不直接删除满足条件的值，而是把不满足条件的值筛选出来作为新的数据源，这样就把要删除的行过滤掉了。
在如下例子中，要删除年龄值大于等于40对应的行，我们并不直接删除这一部分，而是把它的相反部分取出来，即把年龄小于40的行筛选出来作为新的数据源。

7.5 数值计数
数值计数就是计算某个值在一系列数值中出现的次数。

Excel实现
在Excel中实现数值计数，我们使用的是COUNTIF()函数， COUNTIF()函数用来计算某个区域中满足给定条件的单元格数目。

$=COUNTIF(range,criteria)$

range表示一系列值的范围，criteria表示某一个值或者某一个条件。 销售ID的值的计数结果如下图所示。销售ID为1的值在F2:F6这个范围内出现了两次；销售ID为2的值在该范围内也出现了两次；销售ID为3的值出现了1次。

Python实现

在Python中，要对某些值的出现次数进行计数，我们用到的方法是value_counts()。

```python
df['销售ID'].value_counts()
df['销售ID'].value_counts(normalize = True)
df['销售ID'].value_counts(normalize = True,sort = False)
```

上面代码运行的结果表示销售ID为2的值出现了两次，销售ID为1的值出现了两次，销售ID为3的值出现了1次。这些是值出现的绝对次数，还可以看一下不同值出现的占比，只需要给value_counts()方法传入参数normalize = True即可。

上面代码的运行结果表示销售ID为2的值的占比为0.4，销售ID为1的值的占比为0.4，销售ID为3的值的占比为0.2。上面销售ID的排序是2、1、3，这是按照计数值降序排列的（0.4、0.4、0.2），通过设置sort=False可以实现不按计数值降序排列。

7.6 唯一值获取

唯一值获取就是把某一系列值删除重复项以后的结果，一般可以将表中某一列认为是一系列值。

Excel实现
在Excel中，我们若想查看某一列数值中的唯一值，可以把这一列 数值复制粘贴出来，然后删除重复项，剩下的就是唯一值了。

Python实现

在Python中，我们要获取一列值的唯一值，整体思路与Excel的是一致的，先把某一列的值复制粘贴出来，然后用删除重复项的方法实现，关于删除重复项在前面讲过了，本节用另一种获取唯一值的方法unique()实现。

举个例子，对表df中的销售ID取唯一值，先把销售ID取出来，然后利用unique()方法获取唯一值。

```python
df['销售ID'].unique()
```

7.7 数值查找
数值查找就是查看数据表中的数据是否包含某个值或者某些值。
Excel实现
在Excel中我们要想查看数据表中是否包含某个值可以直接利用查 找功能。首先要把待查找区域选中，可以选择一列或者多列，如果不选，则默认在全表中查询，然后单击编辑菜单栏的查找和选择按钮，在下拉菜单中选择查找选项，如下图所示。
下图为选择查找选项后弹出的查找和替换对话框（也可以使用快捷键Ctrl+F打开查找和替换对话框），在查找内容框输入要查找的内容即 可，可以选择查找全部，这样就会把所有查找到的内容显示出来；也可以选择查找下一个，这样会把查找结果一个一个显示出来。

Python实现

在Python中查看数据表中是否包含某个值用到的是isin()方法，而且 可以同时查找多个值，只需要在isin方法后的括号中指明即可。 可以将某列数据取出来，然后在这一列上调用 isin()方法，看这一 列中是否包含某个/些值，如果包含则返回True，否则返回False。也可以针对全表查找是否包含某个值。

7.8 区间切分
区间切分就是将一系列数值分成若干份，比如现在有10个人，你要根据这10个人的年龄将他们分为三组，这个切分过程就称为区间切分。
Excel实现
在Excel中实现区间切分我们借助的是if函数，具体公式如下：
if函数的实现流程如下图所示。
下图为利用if嵌套函数实现的结果。

Python实现
在Python中对区间切分利用的是cut()方法，cut()方法有一个参数 bins用来指明切分区间。
cut()方法的切分结果是几个左开右闭的区间，(0,3]就表示大于0小 于等于3,(3,6]表示大于3小于等于6,(6,10]表示大于6小于等于10。
与cut()方法类似的还有qcut()方法，qcut()方法不需要事先指明切分 区间，只需要指明切分个数，即你要把待切分数据切成几份，然后它就会根据待切分数据的情况，将数据切分成事先指定的份数，依据的原则就是每个组里面的数据个数尽可能相等。
在数据分布比较均匀的情况下，cut()方法和 qcut()方法得到的区间 基本一致，当数据分布不均匀，即方差比较大时，两者得到的区间的偏差就会比较大。

7.9 插入新的行或列

在特定的位置插入行或者列也是比较常用的操作。具体的插入操作有两个关键要素，一个是在哪插入，另一个是插入什么。
Excel实现
在Excel中要插入行或列首先要确定在哪一行或哪一列前面插入， 然后选中这一列或这一行单击鼠标右键，在弹出的下拉菜单中选择插入选项即可。
要在唯一识别码列前面插入一列，选中唯一识别码这一列然后单击鼠标右键，在弹出的下拉菜单中选择插入选项即可，如下图所示。
完成上面的操作后，就会有一个新的空行或空列，在空行或空列里面输入要插入的数据即可。

Python实现
在Python中没有专门用来插入行的方法，可以把待插入的行当作一 个新的表，然后将两个表在纵轴方向上进行拼接。关于表拼接在后面的章节会讲。
在Python中插入一个新的列用到的方法是insert()，在insert方法后的 括号中指明要插入的位置、插入后新列的列名，以及要插入的数据。
还可以直接以索引的方式进行列的插入，直接让新的一列等于某列值即可。
上面的代码表示新插入一列名为商品类别的值，这一列的值就是后面列表中的值。

7.10 行列互换
所谓的行列互换（又称转置）就是将行数据转换到列方向上，将列数据转换到行方向上。
Excel实现
在Excel中行列互换（转置）需要先把待转置的内容复制，然后粘贴在新的区域中，粘贴选项选择转置即可，转置选项如下图所示。
转置前后的效果对比如下图所示。

Python实现
在 Python 中，我们直接在源数据表的基础上调用.T 方法即可得到源数据表转置后的结果。对转置后的结果再次转置就会回到原来的结果。
对表df进行转置，代码如下所示。
对转后的表再次进行转置，代码如下所示。

7.11 索引重塑

所谓的索引重塑就是将原来的索引进行重新构造。典型的DataFrame结构的表如下表所示。
上面这种表是典型的DataFrame结构，它用一个行索引和一个列索 引来确定一个唯一值，比如S1-C1唯一值为1,S2-C3唯一值为6。这种通过两个位置确定一个唯一值的方法不仅可以用上述这种表格型结构表示，而且可以用一种树形结构来表示，如下图所示。
树形结构其实就是在维持表格型行索引不变的前提下，把列索引也变成行索引，其实就是给表格型数据建立层次化索引。
我们把数据从表格型数据转换到树形数据的过程叫重塑，这种操作在Excel中没有，在Python用到的方法是stack()，示例代码如下所示。
与stack()方法相对应的方法是unstack()方法，stack()方法是将表格型数据转化为树形数据，而unstack()方法是将树形数据转为表格型数据， 示例代码如下所示。

7.12 长宽表转换
长宽表转换就是将比较长（很多行）的表转换为比较宽（很多列）的表，或者将比较宽的表转化为比较长的表。
下表是一个宽表（有很多列）。
我们要把这个宽表转化为如下表所示的长表。
上面这种由很多列转换为很多行的过程，就是宽表转换为长表的过程，这种转换过程是有前提的，那就是需要有公共列。
7.12.1 宽表转换为长表
宽表转化为长表，在Excel中一般都用复制粘贴实现，我们主要看 看在Python中如何实现。Python中要实现这种转换有两种方法，一种是stack()方法，另一种是melt()方法。 stack()方法实现stack()在将表格型数据转为树形数据时，是在保持行索引不变的前 提下，将列索引也变成行索引。
这里将宽表转化为长表首先要在保持 Company 和 Name 不变的前提下，将Sale2013、Sale2014、Sale2015、Sale2016也变成行索引。所以，需要先将 Company和Nmae先设置成索引，然后调用stack()方法， 将列索引也转换成行索引，最后利用reset_index()方法进行索引重置， 示例代码如下所示。

melt()方法实现
用melt()方法实现上述功能，代码如下所示。
melt中的id_vars参数用于指明宽表转换到长表时保持不变的列，var_name参数表示原来的列索引转化为“行索引”以后对应的列名，value_name表示新索引对应的值的列名。 注意，这里的“行索引”是有双引号的，它并非实际行索引，只是类似实际的行索引。

7.12.2 长表转换为宽表
将长表转化为宽表就是宽表转化为长表的逆过程。常用的方法就是数据透视表，关于数据透视表的使用我们将在10.2节进行详细讲解，这里大概了解一下就行，具体实现如下：
上面的实现过程是把Company和Name设置成行索引，Year设置成列索引，Sale为值。

7.13 apply()与applymap()函数

我们在Python基础知识部分讲过一个Python的高级特性map()函数，map()函数是对一个序列中的所有元素执行相同的函数操作。
在DataFrame中与map()函数类似的函数有两个，一个是apply()函数，另一个是applymap()函数。函数apply()和applymap()都需要与匿名函数lambda结合使用。apply()函数主要用于对DataFrame中的某一column或row中的元素执行相同的函数操作。

列中的每一个元素加1

applymap()函数用于对DataFrame中的每一个元素执行相同的函数操作。

# 数据运算

这一章我们主要看看这些指标都是怎么计算出来的。

8.1 算术运算
算术运算就是基本的加减乘除，在Excel或Python中数值类型的任意 两列可以直接进行加、减、乘、除运算，而且是对应元素进行加、减、乘、除运算，Excel 中的算术运算比较简单，这里就不展开了，下面主要介绍Python中的算术运算。 两列相加的具体实现如下所示。
两列相减的具体实现如下所示。
两列相乘的具体实现如下所示。
两列相除的具体实现如下所示。
任意一列加/减一个常数值，这一列中的所有值都加/减这个常数值，具体实现如下所示。
任意一列乘/除一个常数值，这一列中的所有值都乘/除这一常数值，具体实现如下所示。

8.2 比较运算
比较运算和Python基础知识中讲到的比较运算一致，也是常规的大 于、等于、小于之类的，只不过这里的比较是在列与列之间进行的。常用的比较运算符见2.9.2节。
在Excel中列与列之间的比较运算和Python中的方法一致，例子如下 图所示。
下面是一些Python中列与列之间比较的例子。

8.3 汇总运算
上面讲到的算术运算和比较运算都是在列与列之间进行的，运算结果是有多少行的值就会返回多少个结果，而汇总运算是将数据进行汇总返回一个汇总以后的结果值。

8.3.1 count非空值计数
非空值计数就是计算某一个区域中非空（单元格）数值的个数。
在Excel中counta()函数用于计算某个区域中非空单元格的个数。与 counta()函数类似的一个函数是count()函数，它用于计算某个区域中含 有数字的单元格的个数。
在 Python 中，直接在整个数据表上调用 count()函数，返回的结果 为该数据表中每列的非空值的个数，具体实现如下所示。
count()函数默认是求取每一列的非空数值的个数，可以通过修改 axis参数让其等于1，来求取每一行的非空数值的个数。
也可以把某一列或者某一行索引出来，单独查看这一列或这一行的非空值个数。

8.3.2 sum求和
求和就是对某一区域中的所有数值进行加和操作。
在 Excel 中要求取某一区域的和，直接在 sum()函数后面的括号中 指明要求和的区域，即要对哪些值进行求和操作即可。例子如下所示。
在Python中，直接在整个数据表上调用sum()函数，返回的是该数据 表每一列的求和结果，例子如下所示。
sum()函数默认对每一列进行求和，可通过修改axis参数，让其等于 1，来对每一行的数值进行求和操作。
也可以把某一列或者某一行索引出来，单独对这一列或这一行数据进行求和操作。

8.3.3 mean求均值
求均值是针对某一区域中的所有值进行求算术平均值运算。均值是用来衡量数据一般情况的指标，容易受到极大值、极小值的影响。
在Excel中对某个区域内的值进行求平均值运算，用的是average()函 数，只要在average()函数中指明要求均值运算的区域即可，比如：
在Python中的求均值利用的是mean()函数，如果对整个表直接调用 mean()函数，返回的是该表中每一列的均值。
mean()函数默认是对数据表中的每一列进行求均值运算，可通过修 改 axis 参数，让其等于1，来对每一行进行求均值运算。
也可以把某一列或者某一行通过索引的方式取出来，然后在这一行或这一列上调用mean()函数，单独求取这一行或这一列的均值。

8.3.4 max求最大值
求最大值就是比较一组数据中所有数值的大小，然后返回最大的一个值。
在Excel和Python中，求最大值使用的都是max()函数，在Excel中同样只需要在max()函数中指明要求最大值的区域即可；在Python中，和其他函数一样，如果对整个表直接调用max()函数，则返回该数据表中每一列的最大值。max()函数也可以对每一行求最大值，还可以单独对某一行或某一列求最大值。
8.3.5 min求最小值
求最小值与求最大值是相对应的，通过比较一组数据中所有数值的大小，然后返回最小的那个值。
在Excel和Python中都使用min()函数来求最小值，它的使用方法与 求最大值的类似，这里不再赘述。示例代码如下。

8.3.6 median求中位数
中位数就是将一组含有n个数据的序列X按从小到大排列，位于中间位置的那个数。
中位数是以中间位置的数来反映数据的一般情况，不容易受到极大值、极小值的影响，因而在反映数据分布情况上要比平均值更有代表性。
现有序列为X:{X1、X2、X3、......、Xn}。
如果n为奇数，则中位数：
如果n为偶数，则中位数：
例如，1、3、5、7、9的中位数为5，而1、3、5、7的中位数为(3+5)/2=4。
在Excel和Python中求一组数据的中位数，都是使用median()函数来 实现的。
下面为在Excel中求中位数的示例：
在Python中，median()函数的使用原则和其他函数的一致。

8.3.7 mode求众数
顾名思义，众数就是一组数据中出现次数最多的数，求众数就是返回这组数据中出现次数最多的那个数。
在Excel和Python中求众数都使用mode()函数，使用原则与其他函数完全一致。
在Excel中求众数的示例如下：
在Python中求众数的示例如下：

8.3.8 var求方差
方差是用来衡量一组数据的离散程度（即数据波动幅度）的。
在Excel和Python中求一组数据中的方差都使用var()函数。 下面为在Excel中求方差的示例：在Python中，var()函数的使用原则和其他函数的一致。
8.3.9 std求标准差
标准差是方差的平方根，二者都是用来表示数据的离散程度的。
在Excel中计算标准差使用的是stdevp()函数，示例如下：
在Python中计算标准差使用的是std()函数，std()函数的使用原则与其他函数的一致，示例如下：

8.3.10 quantile求分位数
分位数是比中位数更加详细的基于位置的指标，分位数主要有四分之一分位数、四分之二分位数、四分之三分位数，而四分之二分位数就是中位数。
在Excel中求分位数用的是percentile()函数，示例如下：
在Python中求分位数用的是quantile()函数，要在quantile后的括号中指明要求取的分位数值，quantile()函数与其他函数的使用规则相同。

8.4 相关性运算
相关性常用来衡量两个事物之间的相关程度，比如我们前面举的例子：啤酒与尿布二者的相关性很强。我们一般用相关系数来衡量两者的相关程度，所以相关性计算其实就是计算相关系数，比较常用的是皮尔逊相关系数。

在Excel中求取相关系数用的是correl()函数，示例如下：
在Python中求取相关系数用的是corr()函数，示例如下：
还可以利用 corr()函数求取整个 DataFrame 表中各字段两两之间的相关性，示例如下：

# 时间序列

9.1 获取当前时刻的时间
获取当前时刻的时间就是获取此时此刻与时间相关的数据，除了具体的年、月、日、时、分、秒，还会单独看年、月、周、日等指标。

9.1.1 返回当前时刻的日期和时间
返回当前时刻的日期和时间在Excel和Python中都借助函数now()实现。
在Excel中直接在单元格里输入now()函数即可，在Python中则使用如下代码：

9.1.2 分别返回当前时刻的年、月、日
返回当前时刻的年份在Excel和Python中都借助函数year实现。 在Excel的单元格中输入如下函数：
在Python中使用如下代码：
返回当前时刻的月份在Excel和Python中都借助函数month实现。 在Excel的单元格中输入如下函数：
在Python中使用如下代码：
返回当前时刻的日在Excel和Python中都借助函数day实现。 在Excel的单元格中输入如下函数：
在Python中使用如下代码：
上面几个函数在其他任意日期或时间中都适用。

9.1.3 返回当前时刻的周数
与当前时刻的周相关的数据有两个，一个是当前时刻是一周中的周几，另一个是返回当前时刻所在的周在全年的周里面是第几周。
返回周几
返回当前时刻是周几在Excel和Python中都借助weekday()函数实现。
在Excel的单元格中输入如下函数：
之所以用“now()-1”是因为Excel把周日作为一周中的第一天。
在Python中使用如下代码：
Python中周几是从0开始数的，周日返回的是6，所以在后面加1。 返回周数
返回当前时刻所在周的周数在Excel中使用的是weeknum()函数，在Python中使用的是isocalendar()函数。
在Excel的单元格中输入如下函数：
在Python中使用如下代码：
上面两个函数在其他任意日期或时间中都适用。

9.2 指定日期和时间的格式
Excel实现
在Excel中要设置日期的时间格式，直接选中要设置的单元格，然 后单击鼠标右键，在弹出的下拉菜单中选择设置单元格格式选项即可设置单元格格式。因为日期和时间是两个概念，所以在Excel中设置日期和时间是分开的，如下图所示。

Python实现

借助date()函数将日期和时间设置成只展示日期。
借助time()函数将日期和时间设置成只展示时间。
借助strftime()函数可以自定义时间和日期的格式，strftime()函数是将日期和时间的格式转化为某些自定义的格式，具体的格式有以下几种。
用strftime()函数自定义时间和日期的格式的例子如下所示。

9.3 字符串和时间格式相互转换

字符串和时间格式的相互转换主要用于Python中。

9.3.1 将时间格式转换为字符串格式

使用str()函数将时间格式转换为字符串格式，示例如下：

9.3.2 将字符串格式转换为时间格式

使用parse()函数将字符串格式转换为时间格式。

9.4 时间索引
时间索引就是根据时间来对时间格式的字段进行数据选取的一种索引方式。
Excel实现
在Excel中，对于时间格式的列有专门的日期筛选，根据需要选择相应的筛选条件即可，筛选条件如下图所示。

Python实现

在Python中，可以选取具体的某一时间对应的值，也可以选取某一段时间内的值。
新建一个时间索引的DataFrame如下：
获取2018年的数据：
获取2018年1月的数据：
获取2018年1月1日到2018年1月5日的数据：
获取2018年1月1日的数据：
上面的索引方法适用于索引是时间的情况下，但是并不是在所有情况下，时间都可以做索引，比如一个订单表中客户姓名是索引，成交时间就是一个普通列，这个时候你想选取某一段时间内的成交订单该怎么办呢？
因为时间也是有大小关系的，所以我们可以利用前面学过的索引方式中的布尔索引来对非索引列的时间进行选取，代码如下：

9.5 时间运算

9.5.1 两个时间之差
在日常业务中经常会用到计算两个时间的差，比如要计算一个用户在某平台上的生命周期，则用用户最后一次登录产品的时间减去用户首次登录产品的时间即可得到。

Excel实现
在Excel中两日期直接做差会得到一个带小数点的天数，如果只想 看两日期之间差多少天，那么直接取整数部分即可；如果想看两日期之间差多少小时、分钟，则需要对小数部分进行计算，小数部分乘24得到的结果中的整数部分就是小时数，它的小数部分再乘60就是分钟数。

Python实现
在Python中两个时间做差会返回一个timedelta对象，该对象中包含天数、秒、微秒三个等级，如果要获取小时、分钟，则需要进行换算。

9.5.2 时间偏移
时间偏移是指给时间往前推或往后推一段时间，即加或减一段时间。

Excel实现
由于Excel中的运算单位都是天，因此若想对某一个时间具体加/减某一单位的时间，如果是加/减小时或者分钟，则需要把小时或分钟换算成对应的天。

Python实现
在Python中实现时间偏移的方式有两种：第一种是借助timedelta， 但是它只能偏移天、秒、微秒单位的时间；第二种是用Pandas中的日期偏移量（date offset）。 

● timedelta
由于timedelta只支持天、秒、微秒单位的时间运算，如果是其他单 位的时间运算，则需要换算成以上三种单位中的一种方可进行偏移。
● date offset
date offset 可以直接实现天、小时、分钟单位的时间偏移，不需要换算，相比timedelta要方便一些。

# 数据分组与数据透视表

10.1 数据分组
数据分组就是根据一个或多个键（可以是函数、数组或df列名）将 数据分成若干组，然后对分组后的数据分别进行汇总计算，并将汇总计算后的结果进行合并，被用作汇总计算的函数称为聚合函数。数据分组的具体分组流程如下图所示。
先简单介绍一下在Excel中的数据分组是如何实现的，然后详细介绍Python是如何实现数据分组的。

Excel实现
Excel 中有数据分组这个功能，但是在使用这个功能以前要先对键进行排序（你要按照哪一列进行分组，那么键就是这一列），升序或降序都可以，排序前后的结果如下图所示。
键值排序完成后，选中待分组区域，然后依次单击菜单栏中的数据分类汇总即可。分类字段、汇总方式都可以根据需求选择。汇总方式就是对分组后的数据进行什么样的运算，我们这里进行的是计数运算，因此在选定汇总项中勾选数值复选框。分类汇总对话框及分组结果如下图所示。
Excel中常见的汇总方式如下表所示。

Python实现
在Python中对数据分组利用的是groupby()方法，这个有点类似于sql 中的groupby，在接下来的几个小节里面，我们会重点介绍Python中的groupby()方法。

10.1.1 分组键是列名
分组键是列名时直接将某一列或多列的列名传给groupby()方法， groupby()方法就会按照这一列或多列进行分组。 按照一列进行分组从上面的结果可以看出，如果只是传入列名，运行groupby()方法以后返回的不是一个DataFrame对象，而是一个DataFrameGroupBy对象，这个对象里面包含着分组以后的若干组数据，但是没有直接显示出来，需要对这些分组数据进行汇总计算以后才会展示出来。
上面的代码是根据客户分类对所有数据进行分组，然后对分组以后的数据分别进行计数运算，最后进行合并。
由于对分组后的数据进行了计数运算，因此每一列都会有一个结果，但是如果对分组后的结果做一些数值运算，这个时候就只有数据类型是数值（int、float）的列才会参与运算，比如下面的求和运算。
我们把这种对分组后的数据进行汇总运算的操作称为聚合，使用的函数称为聚合函数，8.3节讲过的汇总运算函数都可以作为聚合函数对分组后的数据进行聚合。
按照多列进行分组
上面分组键是某一列，即按照一列进行分组，也可以按照多列进行分组，只要将多个列名以列表的形式传给groupby()即可，汇总计算方式 与按照单列进行分组以后数据运算的方式一致。
无论分组键是一列还是多列，只要直接在分组后的数据上进行汇总计算，就是对所有可以计算的列进行计算。有的时候我们不需要对所有列进行计算，这个时候就可以把想要计算的列（可以是单列，也可以是多列）通过索引的方式取出来，然后在取出来这列数据的基础上进行汇总计算。
比如我们想看一下A、B、C类客户分别有多少，我们先按照客户分类进行分组，然后把用户ID这一列取出来，在这一列的基础上进行计数汇总计算即可。
10.1.2 分组键是Series
把DataFrame的其中一列取出来就是一个Series，比如下面的df["客户分类"]就是一个Series。
分组键是列名与分组键是Series的唯一区别就是，给groupby()方法传入了什么，其他都一样。可以按照一个或多个Series进行分组，分组以后的汇总计算也是完全一样的，也支持对分组以后的某些列进行汇总计算。
按照一个Series进行分组
按照多个Series进行分组

10.1.3 神奇的aggregate方法
前面用到的聚合函数都是直接在DataFrameGroupBy上调用的，这样分组以后所有列做的都是同一种汇总运算，且一次只能使用一种汇总方式。
aggregate的第一个神奇之处在于，一次可以使用多种汇总方式，比如下面的例子先对分组后的所有列做计数汇总运算，然后对所有列做求和汇总运算。
aggregate的第二个神奇之处在于，可以针对不同的列做不同的汇总运算，比如下面的例子，我们想看不同类别的用户有多少，那么对用户ID 进行计数；我们想看不同类别的用户在7、8月的销量，则需要对销量进行求和。

10.1.4 对分组后的结果重置索引
通过上节代码运行的结果可以看出，DataFrameGroupBy 对象经过汇总运算以后的形式并不是标准的DataFrame形式。为了接下来对分组 结果进行进一步处理与分析，我们需要把非标准形式转化为标准的DataFrame 形式，利用的方法就是重置索引reset_index()方法，具体实现如下所示。

10.2 数据透视表
数据透视表实现的功能与数据分组相类似但又不同，数据分组是在一维（行）方向上不断拆分，而数据透视表是在行、列方向上同时拆分。
下图为数据分组与数据透视表的对比。
数据透视表不管是在Excel还是Python中都是一个很重要的功能，大家需要熟练掌握。
Excel实现
Excel 中的数据透视表在插入菜单栏中，单击插入数据透视表以后就会看到如下图所示的界面。下图左侧为数据透视表中的所有字段，右
侧为数据透视表的选项，把左侧字段拖入右侧对应的框中即完成了数据透视表的制作。
下图展示了让客户分类作为行标签，区域作为列标签，用户 ID 作为值，且值字段的计算类型为计数的结果。
在数据透视表中把多个字段拖到行对应的框中作为行标签，同样把多个字段拖到列对应的框中作为列标签，把多个字段拖到值对应的框中作为值，而且可以对不同的值字段选择不同的计算类型，请大家自行练习。

Python实现

Python中数据透视表的制作原理与Excel中的制作原理是一样的。
Python中的数据透视表用到的是pivot_table()方法。 pivot_table()方法的全部参数如下：
接下来看一些具体实例：客户分类作为index，区域作为columns，用户ID作为values，对values执行count运算，运行结果如下：
上面的运行结果和Excel的不同之处就是没有合计列，Python数据透视表中的合计列默认是关闭的，让其等于True就可以显示出来，示例如下所示。
合计列的名称默认为All，可以通过设置参数margins_name的值进行修改，示例如下所示。
NaN 表示缺失值，我们可以通过设置参数 fill_value 的值对缺失值进行填充，示例如下所示。
aggfunc 用来表示计算类型，当只传入一种类型时，表示对所有的值字段都进行同样的计算；如果需要对不同的值进行不同的计算类型，则需要传入一个字典，其中键为列名，值为计算方式。下面对用户ID进行计数，对7月销量进行求和。
为了便于分析与处理，我们一般会对数据透视表的结果重置索引，利用的方法同样是reset_index()。

# 多表拼接

11.1 表的横向拼接

表的横向拼接就是在横向将两个表依据公共列拼接在一起。
在Excel中实现横向拼接利用的是vlookup()函数，关于vlookup()函数这里就不展开了，相信大家应该都很熟悉。
在 Python 中实现横向拼接利用的 merge()方法，接下来的几节主要围绕 merge()方法展开。

11.1.1 连接表的类型
连接表的类型关注的就是待连接的两个表都是什么类型，主要有3种情况：一对一、多对一、多对多。
一对一
一对一就是待连接的两个表的公共列是一对一的，例子如下所示。
如果要将df1和df2这两个表进行连接，那么直接使用pd.merge()方法即可，该方法会自动寻找两个表中的公共列，并将找到的公共列作为连接列，上面例子中表 df1和 df2的公共列为学号，且学号是一对一的，两 个表运行 pd.merge()方法以后结果如下：

多对一
多对一就是待连接的两个表的公共列不是一对一的，其中一个表的公共列有重复值，另一个表的公共列是唯一的。
现在有一份名单 df1，其中记录了每位学生升入高三以后的第一次模拟考试的成绩，还有一份名单df2记录了学号及之后每次模拟考试的成绩。要将这两个表按照学号进行连接，由于这两个表是多对一关系，df1中的学号是唯一的，但是 df2中的学号不是唯一的，因此拼接结果就 是保留df2中的重复值，且在df1中也增加重复值，实现代码如下：
多对多
多对多就是待连接的两个表的公共列不是一对一的，且两个表中的公共列都有重复值，多对多连接相当于多个多对一连接，看下面这个例子：

11.1.2 连接键的类型
默认以公共列作为连接键
如果事先没有指定要按哪个列进行拼接时，pd.merge()方法会默认 寻找两个表中的公共列，然后以这个公共列作为连接键进行连接，比如下面这个例子，默认以公共列学号作为连接键：
用on来指定连接键 也可以用参数on来指定连接键，参数on一般指定的也是两个表中的 公共列，其实这个时候和使用默认公共列达到的效果是一样的。
公共列可以有多列，也就是连接键可以有多个，比如下面这个例子
用学号和姓名两列做连接键：
分别指定左右连接键
当两个表中没有公共列时，这里指的是实际值一样，但列名不同，否则就无法连接了。这个时候要分别指定左表和右表的连接键，使用的
参数分别是left_on和rigth_on, left_on用来指明左表用作连接键的列名，right_on用来指明右表用作连接键的列名，例子如下：
把索引列当作连接键
索引列不算是真正的列，当公共列是索引列时，就要把索引列当作连接键，使用的参数分别是 left_index 和 right_index,left_index 用来控制
左表的索引，right_index用来控制右表的索引，下例中的左、右表的连 接键均为各自的索引。
在上面的例子中，左表和右表的连接键均为索引，还可以把索引列和普通列混用，下例中左表的连接键为索引，右表的连接键为普通列。

11.1.3 连接方式
前两个小节我们举的例子比较标准，也就是左表中的公共列的值都可以在右表对应的公共列中找到，右表公共列的值也可以在左表对应的
公共列中找到，但是现实业务中很多是互相找不到的，这个时候该怎么办呢？这就衍生出了用来处理找不到的情况的几种连接方式，用参数
how来指明具体的连接方式。

内连接（inner）
内连接就是取两个表中的公共部分，在下面的例子中，学号100、101、102是两个表中的公共部分，内连接以后就只有这三个学号对应的
内容。
如果不指明连接方式，则默认都是内连接。
左连接（left） 左连接就是以左表为基础，右表往左表上拼接。下例的右表中没有学号为103的信息，拼接过来的信息就用NaN填充。
右连接（right）
右连接就是以右表为基础，左表往右表上拼接。下例的左表中没有学号为104的信息，拼接过来的信息就用NaN填充。
外连接（outer）
外连接就是取两个表的并集。下例中表df1中学号为100、101、102、103，表df2中学号为100、101、102、104，因此外连接取并集以
后的结果中应包含学号为100、101、102、103、104的信息。

11.1.4 重复列名处理
两个表在进行连接时，经常会遇到列名重复的情况。在遇到列名重复时，pd.merge()方法会自动给这些重复列名添加后缀_x、_y或_z，而 且会根据表中已有的列名自行调整，比如下面这个例子中的姓名列：
当然我们也可以自定义重复的列名，只需要修改参数 suffixes的值即可，默认为["_x","_y"]。
11.2 表的纵向拼接
表的纵向拼接是与横向拼接相对应的，横向拼接是两个表依据公共列在水平方向上进行拼接，而纵向拼接是在垂直方向进行拼接。
一般的应用场景就是将分离的若干个结构相同的数据表合并成一个数据表，比如下面是两个班的花名册，这两个表的结构是一样的，需要
把这两个表进行合并。
在Excel中两个结构相同的表要实现合并，只需要把表二复制粘贴 到表一的下方即可。
在Python中想纵向合并两个表，需要用到concat()方法。
11.2.1 普通合并
普通合并就是直接将待合并表的表名以列表的形式传给pd.concat() 方法，运行代码，即可完成合并，例子如下：
这样就把一班的花名册和二班的花名册合并到了一起。
11.2.2 索引设置
pd.concat()方法默认保留原表的索引，在11.2.1节的例子中表df1的索引列编号和表df2的索引列编号一样，合并后的索引列编号就显示为 12341234，但是这样看着很不顺眼。
我们可以通过设置参数ignore_index的值，让其等于True，这样就会 生成一组新的索引，而不保留原表的索引，如下所示。
11.2.3 重叠数据合并
前面的数据都是比较干净的数据，现实中难免会有一些错误数据，比如一班的花名册里写进了二班的人，而这个人在二班的花名册里也出
现了，这个时候如果直接合并两个表，肯定会有重复值，那么该怎么处理呢？

我们先调用concat()函数，看是什么结果：
在上面的结果中“葛颜”出现了两次，前面讲过的重复值处理是不是可以处理这种情况呢？答案是肯定的，具体实现如下所示。

经过删除重复值以后，“葛颜”就只出现一次了。

# 结果导出

12.1 导出为.xlsx文件
在Excel中要将文件保存为.xlsx格式的文件，直接将文件另存为即 可，在另存为时选择Excel工作簿(.xlsx)格式，如下图所示。
如果是将文件导出，那么只有PDF/XPS两种格式可选，如下图所示。
在Python中将文件导出为.xlsx格式，用到的是df.to_excel()方法，接下来的几个小节具体讲解to_excel()方法。
12.1.1 设置文件导出路径
设置文件导出路径就是告诉Python要将这个文件导出到电脑的哪个 文件夹里，且导出以后这个文件叫什么。通过调整参数excel_writer的值 即可实现。
上面代码表示将表df导出到桌面，且导出以后的文件名为测试文 档，导出以后的文档如下所示。
需要注意的是，如果同一导出文件已经在本地打开，则不能再次运行导出代码，会报错，需要将本地文件关闭以后再次运行导出代码。这有点类似于在本地修改文件名的操作，如果文件是打开的，即被占用的状态，那么不可以执行修改文件的操作。
12.1.2 设置Sheet名称
.xlsx格式的文件有多个Sheet,Sheet的默认命名方式是Sheet后加阿拉伯数字，通常从 Sheet1往上递增，我们也可以对默认的 Sheet 名字进行修改，只要修改sheet_name参数即可，具体实现如下所示。
运行上面代码以后，导出到本地文件的Sheet名字将从原来的Sheet1 变成测试文档。
12.1.3 设置索引
上面导出文件中关于索引的参数都是默认的，也就是没有对索引做什么限制，但是我们可以看到index索引使用的是从0开始的默认自然数索引，这种索引是没有意义的，设置参数index=False就可以在导出时把这种索引去掉，具体实现如下所示。
上面代码运行的结果如下图所示，从0开始的自然数索引没有被展示出来。
12.1.4 设置要导出的列
有的时候一个表的列数很多，我们并不需要把所有的列都导出，这个时候就可以通过设置columns参数来指定要导出的列，这和导入时设置只导入部分列的原理类似，代码如下所示。
下图为只导出用户ID、7月销量、8月销量、9月销量的结果文件。
12.1.5 设置编码格式
我们在导入文件时需要设置编码格式，导出文件的时候同样也需要，修改编码格式的参数与导入文件时的一致，也使用的encoding,encoding参数值一般选择"utf-8"。
12.1.6 缺失值处理
虽然我们在前面的数据预处理过程中已经处理了缺失值，但是在数据分析过程中也可能会产生一些缺失值，如果在导出的时候，数据表中有缺失值，那么就要对表中的缺失值进行填充，使用的参数为na_rep，具体实现如下所示。
12.1.7 无穷值处理
无穷值（inf）与缺失值（Nan）都是异常数据，当你用一个浮点数 除以0时，就会得到一个无穷值，无穷值的存在会导致接下来的计算报错，所以需要对无穷值进行处理。
可以通过下面这种方式生成正无穷值与负无穷值。
下面的数据表中含有inf值，要把inf值替换掉，就要设置参数inf_rep 的值。
把inf_rep的值填充为0，具体实现如下所示。
下图为导出到本地的文档，可以看到inf值已经被替换成0了。
12.2 导出为.csv文件
在Excel中要将文件保存为.csv格式，直接将文件另存为，在另存为 时有两种.csv文件可选，这两种文件虽然后缀均为.csv，但是编码方式不
同，CSV UTF-8(逗号分隔)(.csv)采用的编码格式是 UTF-8，而 CSV(逗号分隔)(*.csv)采用的编码格式是 gbk编码，如下图所示。
在Python中，将文件导出为.csv文件使用的是to_csv方法，接下来的几个小节具体讲解to_csv方法的一些参数。
12.2.1 设置文件导出路径
设置.csv 文件的导出路径时，与设置.xlsx 文件的导出路径一样，但 是参数不一样，.csv文件的导出路径需通过path_or_buf参数来设置。
导出.csv文件时的注意事项与导出.xlsx文件时的注意事项一致：如果同一导出文件已经在本地打开，则不能再次运行导出代码，那样会报错，需要将本地文件关闭以后再运行导出代码。
12.2.2 设置索引
导出.csv 文件时与导出.xlsx 文件时对索引的设置是一致的，可以通过设置 index参数，让从0开始的默认自然数索引不展示出来。
12.2.3 设置要导出的列
导出.csv文件时也可以设置要导出哪些列，用的参数同样是columns。
12.2.4 设置分隔符号
分隔符号就是用来指明导出文件中的字符之间是用什么来分隔的，默认使用逗号分隔，常用的分隔符号还有空格、制表符、分号等。用参数sep来指明要用的分隔符号。
12.2.5 缺失值处理
导出.csv文件时用的缺失值处理方法与导出.xlsx文件时用的缺失值 处理方法是一样的，也是通过参数na_rep来指明要用什么填充缺失值。
12.2.6 设置编码格式
在Python 3中，导出为.csv文件时，默认编码为UTF-8，如果使用默 认的UTF-8编码格式，导出的文件在本地电脑打开以后中文会乱码，所以一般使用utf-8-sig或者gbk编码。
12.3 将文件导出到多个Sheet
有的时候一个脚本一次会生成多个文件，可以将多个文件分别导出成多个文件，也可以将多个文件放在一个文件的不同 Sheet 中，这个时候要用ExcelWriter()函数将多个文件分别导出到不同Sheet中，具体方法如下：